#include <furi.h>
#include <gui/gui.h>
#include <gui/view_port.h>
#include <gui/canvas.h>
#include <input/input.h>
#include <infrared.h>
#include <infrared_signal.h>

/* generated by fbt from .png files in images folder */
#include <netflixtvremote_icons.h>

#define GRID_ROWS 2
#define GRID_COLS 4

typedef struct {
    int x;
    int y;
    const Icon* icon_light;
    const Icon* icon_dark;
    bool active;
} GridButton;

int selected_row = 1;
int selected_col = 0;
bool dpad_active = false;

GridButton grid[GRID_ROWS][GRID_COLS] = {
    {
        {21, 5, &I_netflix_20x19, &I_netflix_hover_20x19, true},
        {47, 5, &I_play_pause_20x19, &I_play_pause_hover_20x19, true},
        {76, 5, &I_mute_20x19, &I_mute_hover_20x19, true},
        {104, 6, &I_dpad_20x52, &I_dpad_hover_20x52, true},
    },
    {
        {21, 36, &I_power_20x19, &I_power_hover_20x19, true},
        {47, 34, &I_volup_21x24, &I_volup_hover_21x24, true},
        {76, 34, &I_voldown_21x24, &I_voldown_hover_21x24, true},
        {104, 6, &I_dpad_20x52, &I_dpad_hover_20x52, true},
    },
};

const InfraredMessage IR_NETFLIX = {InfraredProtocolSIRC15, 0x1A, 0x7C, false};
const InfraredMessage IR_PLAY = {InfraredProtocolSIRC15, 0x97, 0x1A, false};
const InfraredMessage IR_MUTE = {InfraredProtocolSIRC, 0x01, 0x14, false};
const InfraredMessage IR_POWER = {InfraredProtocolSIRC, 0x01, 0x15, false};
const InfraredMessage IR_VOL_UP = {InfraredProtocolSIRC, 0x01, 0x12, false};
const InfraredMessage IR_VOL_DOWN = {InfraredProtocolSIRC, 0x01, 0x13, false};
const InfraredMessage IR_LEFT = {InfraredProtocolSIRC, 0x01, 0x34, false};
const InfraredMessage IR_RIGHT = {InfraredProtocolSIRC, 0x01, 0x33, false};
const InfraredMessage IR_UP = {InfraredProtocolSIRC, 0x01, 0x74, false};
const InfraredMessage IR_DOWN = {InfraredProtocolSIRC, 0x01, 0x75, false};
const InfraredMessage IR_ENTER = {InfraredProtocolSIRC, 0x01, 0x65, false};
const InfraredMessage IR_BACK = {InfraredProtocolSIRC15, 0x97, 0x23, false};

static void send_ir_code(InfraredMessage message) {
    // 1. Allocate memory for an InfraredSignal
    InfraredSignal* signal = infrared_signal_alloc();
    furi_check(signal);

    // 2. Assign the message to the signal structure
    infrared_signal_set_message(signal, &message);

    // 3. Transmit the signal
    infrared_signal_transmit(signal);

    // 4. Free the allocated memory
    infrared_signal_free(signal);
}

static void draw_callback(Canvas* canvas, void* ctx) {
    UNUSED(ctx);

    canvas_draw_icon(canvas, 0, 0, &I_header_18x64);
    canvas_draw_icon(canvas, 55, 32, &I_vol_tv_text_34x29); // decorazione fissa

    for(int row = 0; row < GRID_ROWS; row++) {
        for(int col = 0; col < GRID_COLS; col++) {
            GridButton* btn = &grid[row][col];
            if(!btn->active) continue;

            bool selected = (row == selected_row && col == selected_col);

            if(col == 3 && (selected_row == 0 || selected_row == 1) && selected_col == 3) {
                selected = true;
            }

            const Icon* icon = selected ? btn->icon_dark : btn->icon_light;
            canvas_draw_icon(canvas, btn->x, btn->y, icon);
        }
    }
}

static void draw_dpad_callback(Canvas* canvas, void* ctx) {
    UNUSED(ctx);
    canvas_draw_icon(canvas, 0, 0, &I_dpad_scene_128x64);
}

static void input_callback(InputEvent* event, void* ctx) {
    bool* running = ctx;

    if(event->type == InputTypeLong && event->key == InputKeyBack) {
        *running = false;
        return;
    }

    if(event->key == InputKeyOk) {
        if(event->type == InputTypeShort || event->type == InputTypeRepeat) {
            if(selected_col == 3) {
                dpad_active = true;
                return;
            }

            if(selected_row == 0) {
                switch(selected_col) {
                case 0:
                    send_ir_code(IR_NETFLIX);
                    break;
                case 1:
                    send_ir_code(IR_PLAY);
                    break;
                case 2:
                    send_ir_code(IR_MUTE);
                    break;
                }
            } else if(selected_row == 1) {
                switch(selected_col) {
                case 0:
                    send_ir_code(IR_POWER);
                    break;
                case 1:
                    send_ir_code(IR_VOL_UP);
                    break;
                case 2:
                    send_ir_code(IR_VOL_DOWN);
                    break;
                }
            }
        }
        return;
    }

    if(event->type != InputTypeRepeat && event->type != InputTypeShort) {
        return;
    }

    int new_row = selected_row;
    int new_col = selected_col;

    switch(event->key) {
    case InputKeyUp:
        if(new_row > 0) new_row--;
        break;
    case InputKeyDown:
        if(new_row < GRID_ROWS - 1) new_row++;
        break;
    case InputKeyLeft:
        if(new_col > 0) new_col--;
        break;
    case InputKeyRight:
        if(new_col < GRID_COLS - 1) new_col++;
        break;
    case InputKeyBack:
        send_ir_code(IR_BACK);
        break;
    default:
        break;
    }

    if(grid[new_row][new_col].active) {
        selected_row = new_row;
        selected_col = new_col;
    }
}

static void input_dpad_callback(InputEvent* event, void* ctx) {
    UNUSED(ctx);

    if(event->type == InputTypeLong && event->key == InputKeyBack) {
        dpad_active = false;
        return;
    }

    if(event->key == InputKeyUp || event->key == InputKeyDown || event->key == InputKeyLeft ||
       event->key == InputKeyRight || event->key == InputKeyOk || event->key == InputKeyBack) {
        if(event->type == InputTypeShort || event->type == InputTypeRepeat) {
            switch(event->key) {
            case InputKeyUp:
                send_ir_code(IR_RIGHT);
                break;
            case InputKeyDown:
                send_ir_code(IR_LEFT);
                break;
            case InputKeyLeft:
                send_ir_code(IR_UP);
                break;
            case InputKeyRight:
                send_ir_code(IR_DOWN);
                break;
            case InputKeyOk:
                send_ir_code(IR_ENTER);
                break;
            case InputKeyBack:
                send_ir_code(IR_BACK);
                break;
            default:
                break;
            }
        }
        return;
    }
}

int32_t netflixtvremote_app(void* p) {
    UNUSED(p);
    FURI_LOG_I("TEST", "Hello world");
    FURI_LOG_I("TEST", "I'm netflixtvremote!");

    Gui* gui = furi_record_open("gui");

    ViewPort* main_viewport = view_port_alloc();
    ViewPort* dpad_viewport = view_port_alloc();
    bool running = true;

    view_port_draw_callback_set(main_viewport, draw_callback, NULL);
    view_port_input_callback_set(main_viewport, input_callback, &running);

    view_port_draw_callback_set(dpad_viewport, draw_dpad_callback, NULL);
    view_port_input_callback_set(dpad_viewport, input_dpad_callback, &running);

    gui_add_view_port(gui, main_viewport, GuiLayerFullscreen);

    while(running) {
        if(dpad_active) {
            gui_remove_view_port(gui, main_viewport);
            gui_add_view_port(gui, dpad_viewport, GuiLayerFullscreen);
        } else {
            gui_remove_view_port(gui, dpad_viewport);
            gui_add_view_port(gui, main_viewport, GuiLayerFullscreen);
        }
        furi_delay_ms(50);
    }

    gui_remove_view_port(gui, main_viewport);
    view_port_free(main_viewport);
    view_port_free(dpad_viewport);
    furi_record_close("gui");

    return 0;
}
